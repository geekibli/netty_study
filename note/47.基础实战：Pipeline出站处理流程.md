# 47 åŸºç¡€å®æˆ˜ï¼šPipelineå‡ºç«™å¤„ç†æµç¨‹

## å‡ºç«™å¤„ç†å™¨éƒ½åšå“ªäº›äº‹

å®ŒæˆNettyåˆ°åº•å±‚é€šé“çš„æ“ä½œï¼Œæ¯”å¦‚å»ºç«‹åº•å±‚è¿æ¥ï¼Œæ–­å¼€åº•å±‚è¿æ¥ï¼Œå†™å…¥åº•å±‚NIOé€šé“ç­‰ç­‰ã€‚

## ChannelOutBoundHandler æºç 

```java
public interface ChannelOutboundHandler extends ChannelHandler {
	void bind(ChannelHandlerContext var1, SocketAddress var2, ChannelPromise var3) throws Exception;

	void connect(ChannelHandlerContext var1, SocketAddress var2, SocketAddress var3, ChannelPromise var4) throws Exception;

	void disconnect(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;

	void close(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;

	void deregister(ChannelHandlerContext var1, ChannelPromise var2) throws Exception;

	void read(ChannelHandlerContext var1) throws Exception;

	void write(ChannelHandlerContext var1, Object var2, ChannelPromise var3) throws Exception;

	void flush(ChannelHandlerContext var1) throws Exception;
}

```

### bind 
ç›‘å¬åœ°å€ï¼ˆIP + PORTï¼‰ç»‘å®š : å®Œæˆåº•å±‚JAVA IOé€šé“çš„IOåœ°å€ç»‘å®šã€‚ å¦‚æœä½¿ç”¨TCPä¼ è¾“åè®®ï¼Œè¿™ä¸ªæ–¹æ³•ç”¨åœ¨æœåŠ¡ç«¯

### connect
é“¾æ¥æœåŠ¡ç«¯ï¼š å®Œæˆåº•å±‚Java IOé€šé“çš„æœåŠ¡ç«¯çš„é“¾æ¥æ“ä½œï¼Œå¦‚æœä½¿ç”¨çš„æ˜¯TCPä¼ è¾“åè®®ï¼Œè¿™ä¸ªæ–¹æ³•åˆ™ç”¨åœ¨å®¢æˆ·ç«¯

### write 

å†™æ•°æ®åˆ°åº•å±‚ï¼š å®ŒæˆNettyé€šä¿¡å‘åº•å±‚Java IO é€šé“æ•°æ®çš„å†™å…¥ã€‚æ­¤æ–¹æ³•ä»…ä»…æ˜¯è§¦å‘ä¸€ä¸‹æ“ä½œè€Œå·²ï¼Œå¹¶ä¸æ˜¯å®Œæˆå®é™…çš„æ•°æ®å†™å…¥æ“ä½œã€‚   

### flush 

å°†åº•å±‚ç¼“å†²åŒºçš„æ•°æ®è…¾ç©ºï¼Œç«‹å³å†™å‡ºåˆ°å¯¹ç«¯

### read 

ä»åº•å±‚è¯»æ•°æ®ï¼Œå®ŒæˆNettyé€šé“ä»Java IOé€šé“æ•°æ®çš„è¯»å–

### disConnect 

æ–­å¼€æœåŠ¡å™¨è¿æ¥ï¼š æ–­å¼€åº•å±‚Java IO é€šé“çš„socketé“¾æ¥ã€‚å¦‚æœä½¿ç”¨çš„æ˜¯TCPä¼ è¾“åè®®ï¼Œæ­¤æ–¹æ³•ä¸»è¦ä½¿ç”¨åœ¨å®¢æˆ·ç«¯

### close 
ä¸»åŠ¨å…³é—­é€šé“ï¼š å…³é—­Java IO åº•å±‚é€šé“ï¼Œä¾‹å¦‚æœåŠ¡å™¨ç«¯çš„æ–°é“¾æ¥ç›‘å¬é€šé“




## ä»£ç æ¼”ç¤º

```java
public class OutPipeline {
	public class SimpleOutHandlerA extends ChannelOutboundHandlerAdapter {
		@Override
		public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
			Logger.info("å‡ºç«™å¤„ç†å™¨ A: è¢«å›è°ƒ" );
			super.write(ctx, msg, promise);
		}
	}
	public class SimpleOutHandlerB extends ChannelOutboundHandlerAdapter {
		@Override
		public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
			Logger.info("å‡ºç«™å¤„ç†å™¨ B: è¢«å›è°ƒ" );
			super.write(ctx, msg, promise);
		}
	}
	public class SimpleOutHandlerC extends ChannelOutboundHandlerAdapter {
		@Override
		public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
			Logger.info("å‡ºç«™å¤„ç†å™¨ C: è¢«å›è°ƒ" );
			super.write(ctx, msg, promise);
		}
	}
	@Test
	public void testPipelineOutBound() {
		ChannelInitializer i = new ChannelInitializer<EmbeddedChannel>() {
			protected void initChannel(EmbeddedChannel ch) {
				ch.pipeline().addLast(new SimpleOutHandlerA());
				ch.pipeline().addLast(new SimpleOutHandlerB());
				ch.pipeline().addLast(new SimpleOutHandlerC());
			}
		};
		EmbeddedChannel channel = new EmbeddedChannel(i);
		ByteBuf buf = Unpooled.buffer();
		buf.writeInt(1);
		//å‘é€šé“å†™ä¸€ä¸ªå‡ºç«™æŠ¥æ–‡
		channel.writeOutbound(buf);
		try {
			Thread.sleep(Integer.MAX_VALUE);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}

	public class SimpleOutHandlerB2 extends ChannelOutboundHandlerAdapter {
		@Override
		public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
			Logger.info("å‡ºç«™å¤„ç†å™¨ B: è¢«å›è°ƒ" );
			//ä¸è°ƒç”¨åŸºç±»çš„channelRead, ç»ˆæ­¢æµæ°´çº¿çš„æ‰§è¡Œ
//            super.write(ctx, msg, promise);
		}
	}

	@Test
	public void testPipelineOutBoundCutting() {
		ChannelInitializer i = new ChannelInitializer<EmbeddedChannel>() {
			protected void initChannel(EmbeddedChannel ch) {
				ch.pipeline().addLast(new SimpleOutHandlerA());
				ch.pipeline().addLast(new SimpleOutHandlerB2());
				ch.pipeline().addLast(new SimpleOutHandlerC());
			}
		};
		EmbeddedChannel channel = new EmbeddedChannel(i);
		ByteBuf buf = Unpooled.buffer();
		buf.writeInt(1);
		//å‘é€šé“å†™ä¸€ä¸ªå‡ºç«™æŠ¥æ–‡
		channel.writeOutbound(buf);
		try {
			Thread.sleep(Integer.MAX_VALUE);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

	}
```



è¿™ä¸ªä»£ç çœ‹èµ·æ¥æ˜¯ä¸æ˜¯æœ‰äº›ç†Ÿæ‚‰å‘¢ã€‚å…¶å®å’Œå‰ä¸€èŠ‚å…¥ç«™é‚£å—çš„ä»£ç æ˜¯ä¸€æ ·çš„ã€‚

æµ‹è¯•é€šé“å‘¢ï¼ŒåŒæ ·ä½¿ç”¨çš„æ˜¯ï¼š `EmbeddedChannel`

æ‰§è¡Œç»“æœçœ‹ä¸€ä¸‹ï¼š 

```
[main|OutPipeline$SimpleOutHandlerC.write] |>  å‡ºç«™å¤„ç†å™¨ C: è¢«å›è°ƒ 
[main|OutPipeline$SimpleOutHandlerB.write] |>  å‡ºç«™å¤„ç†å™¨ B: è¢«å›è°ƒ 
[main|OutPipeline$SimpleOutHandlerA.write] |>  å‡ºç«™å¤„ç†å™¨ A: è¢«å›è°ƒ 
```

**è¿™é‡Œçœ‹åˆ°ï¼Œæ‰§è¡Œå™¨çš„é¡ºåºæ˜¯ç”±ä¸‹åˆ°ä¸Šçš„ã€‚**

ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ

å¦å¤–éœ€è¦æ³¨æ„çš„ç‚¹ï¼Œæ¯æ¬¡handleræ‰§è¡Œwriteæ–¹æ³•ä¹‹åï¼Œéƒ½æœ‰ä¸€ä¸ªé¢å¤–çš„æ“ä½œï¼š
```java
 public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
	Logger.info("å‡ºç«™å¤„ç†å™¨ A: è¢«å›è°ƒ" );
	super.write(ctx, msg, promise);
}
```


è¿™é‡Œçš„ `super.write(ctx, msg, promise);` çš„ä½œç”¨ï¼š **å°±æ˜¯æŠŠå½“å‰å¤„ç†å™¨å¤„ç†çš„æ•°æ®ä¼ é€’åˆ°ä¸‹ä¸€ä¸ªå¤„ç†å™¨ã€‚**


å¦‚æœä¸è°ƒç”¨å‘¢ï¼Ÿ `super.write(ctx, msg, promise);`

æ‰§è¡ŒtestPipelineOutBoundCuttingæ–¹æ³•ï¼ŒæŸ¥çœ‹æµ‹è¯•æ•ˆæœï¼š å¦‚ä¸‹æ‰€ç¤º
```
[main|OutPipeline$SimpleOutHandlerC.write] |>  å‡ºç«™å¤„ç†å™¨ C: è¢«å›è°ƒ 
[main|OutPipeline$SimpleOutHandlerB2.write] |>  å‡ºç«™å¤„ç†å™¨ B: è¢«å›è°ƒ 
```

å¤„ç†å™¨Aå¹¶æ²¡æœ‰æ‰§è¡Œã€‚


## super.write(ctx, msg, promise) æºç 

è°ƒç”¨super.write(ctx, msg, promise)æ–¹æ³•ä¼šæ‰§è¡Œåˆ°ä¸‹é¢è¿™ä¸ªæ–¹æ³•ï¼š ğŸ‘‡

```
private void write(Object msg, boolean flush, ChannelPromise promise) {
	AbstractChannelHandlerContext next = this.findContextOutbound();
	Object m = this.pipeline.touch(msg, next);
	EventExecutor executor = next.executor();
	if (executor.inEventLoop()) {
		if (flush) {
			next.invokeWriteAndFlush(m, promise);
		} else {
			next.invokeWrite(m, promise);
		}
	} else {
		Object task;
		if (flush) {
			task = AbstractChannelHandlerContext.WriteAndFlushTask.newInstance(next, m, promise);
		} else {
			task = AbstractChannelHandlerContext.WriteTask.newInstance(next, m, promise);
		}

		safeExecute(executor, (Runnable)task, promise, m);
	}

}
```


é¦–å…ˆæ‰§è¡Œï¼š `AbstractChannelHandlerContext next = this.findContextOutbound();` è·å–ä¸‹ä¸€ä¸ªéœ€è¦æ‰§è¡Œçš„å¤„ç†å™¨ä¸Šä¸‹æ–‡å¯¹è±¡

ç„¶ååœ¨æ‰§è¡Œåç»­çš„é€»è¾‘ã€‚ã€‚ã€‚

**çœ‹ä¸€ä¸‹æ˜¯å¦‚ä½•å¯»æ‰¾ä¸‹ä¸€ä¸ªæ‰§è¡Œå™¨çš„ï¼Ÿ**

```java
private AbstractChannelHandlerContext findContextOutbound() {
	AbstractChannelHandlerContext ctx = this;

	do {
		ctx = ctx.prev;
	} while(!ctx.outbound);

	return ctx;
}
```

**æˆ‘ä»¬çŸ¥é“ä¸Šä¸‹æ–‡å…¶å®æ˜¯ä¸€ä¸ªåŒå‘é“¾è¡¨ï¼Œè¿™ä¸ªå’Œå…¥ç«™å¤„ç†å™¨ç›¸åçš„ï¼Œä»å½“å‰å¤„ç†å™¨å‘å‰å¯»æ‰¾ä¸‹ä¸€ä¸ªå¤„ç†å™¨ã€‚**



