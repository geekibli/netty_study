

# 68 åˆ†å¸ƒå¼é«˜é˜¶å®æˆ˜ï¼šNettyèŠ‚ç‚¹çš„ä¹‹é—´çš„è·¯ç”±å’Œè½¬å‘


è¿™ä¸€éƒ¨åˆ†ä¸æ˜¯å¾ˆå¥½ç†è§£ï¼Œç®—æ˜¯æ¯”è¾ƒéš¾çš„éƒ¨åˆ†ï¼Œä¸ºæ­¤å‘¢ï¼Œæˆ‘ç‰¹æ„ç”»äº†ä¸€ä¸ªé€»è¾‘æµç¨‹å›¾è¾…åŠ©ç†è§£ã€‚å¦‚ä¸‹é¢æ‰€ç¤ºğŸ‘‡

åœ¨ä¸Šä¸€ä¸ªç« èŠ‚ä¸­ï¼Œæˆ‘ä»¬è®¾è®¡äº†ä¸€ä¸ªç±»ï¼ŒWorkerRouterã€‚æ¯ä¸€ä¸ªNettyèŠ‚ç‚¹éƒ½ä¼šå¯¹åº”ä¸€ä¸ªWorkerRouterã€‚

å®ƒçš„åŠŸèƒ½åœ¨ä¸Šä¸€èŠ‚ä¸­å·²ç»æåˆ°ä¸€éƒ¨åˆ†ã€‚

ç¬¬ä¸€ï¼Œå®ƒé€šè¿‡è®¢é˜…ZookeeperæŒ‡å®šè·¯å¾„ä¸‹çš„å­—èŠ‚ç‚¹çš„æ›´æ–°ï¼Œé€šè¿‡ç›‘å¬å™¨ï¼Œç›‘å¬NettyèŠ‚ç‚¹çš„çŠ¶æ€ï¼Œå½“ZKæœ‰æ–°çš„å­èŠ‚ç‚¹åˆ›å»ºæ—¶ï¼Œæ„å‘³ç€Nettyé›†ç¾¤ä¸­åŠ å…¥äº†æ–°çš„èŠ‚ç‚¹ã€‚

åŒæ ·ï¼Œå½“èŠ‚ç‚¹åˆ é™¤çš„æ—¶å€™ï¼Œæ„å‘³ç€NettyèŠ‚ç‚¹ç¦»å¼€é›†ç¾¤ï¼Œä»è€Œï¼ŒWorkerRouterå®ç°äº†æœåŠ¡å‘ç°çš„åŠŸèƒ½ã€‚

ç¬¬äºŒï¼Œå¤„ç†æœåŠ¡å‘ç°ï¼ŒWorkerRouterè¿˜å…·å¤‡è·¯ç”±å™¨çš„åŠŸèƒ½ã€‚å½“å®¢æˆ·ç«¯æ¶ˆæ¯è¦å‘é€çš„Sessionä¸å†å½“å‰èŠ‚ç‚¹æ—¶ï¼Œéœ€è¦è½¬å‘å™¨ï¼ˆæœ¬è´¨æ˜¯æ¨¡æ‹Ÿä¸€ä¸ªNettyå®¢æˆ·ç«¯ï¼‰è½¬å‘åˆ°è¿œç¨‹èŠ‚ç‚¹ä¸Šé¢ã€‚


<img src="https://oscimg.oschina.net/oscnet/up-39899486f72e275a1a1e01ff5c50aad59e1.png" height=370>




## èŠ‚ç‚¹ä¿¡æ¯å¦‚ä½•å­˜å‚¨

è¿™é‡Œï¼Œkeyæ˜¯NettyèŠ‚ç‚¹çš„id, valueå¯¹åº”çš„æ˜¯ï¼Œä¸€ä¸ªè½¬å‘å™¨ã€‚

```java
private ConcurrentHashMap<Long, PeerSender> workerMap = new ConcurrentHashMap<>();
```


ä¹‹å‰æåˆ°ï¼Œå½“æœ‰NettyèŠ‚ç‚¹åŠ å…¥é›†ç¾¤ä¸­çš„æ—¶å€™ï¼Œä¼šå‘workerMapä¸­ï¼Œå­˜å‚¨æ•°æ®:

```java
   private void doAfterAdd(ImNode n, PeerSender relaySender) {
	if (null != relaySender) {
		//å…³é—­è€çš„è¿æ¥
		relaySender.stopConnecting();
	}
	//åˆ›å»ºä¸€ä¸ªæ¶ˆæ¯è½¬å‘å™¨
	relaySender = new PeerSender(n);
	//å»ºç«‹è½¬å‘çš„è¿æ¥
	relaySender.doConnect();

	workerMap.put(n.getId(), relaySender);
}
```


## è¿œç¨‹Sessionæ˜¯å¦‚ä½•å‘é€æ•°æ®çš„å‘¢

```java
@Data
@Builder
@AllArgsConstructor
public class RemoteSession implements ServerSession, Serializable {
	private static final long serialVersionUID = -400010884211394846L;
	SessionCache cache;
	private boolean valid = true;

	public RemoteSession(SessionCache cache) {
		this.cache = cache;
	}

	/**
	 * é€šè¿‡è¿œç¨‹èŠ‚ç‚¹ï¼Œè½¬å‘
	 */
	@Override
	public void writeAndFlush(Object pkg) {
		ImNode imNode = cache.getImNode();
		long nodeId = imNode.getId();

		//è·å–è½¬å‘çš„  sender
		PeerSender sender = WorkerRouter.getInst().route(nodeId);

		if (null != sender) {
			sender.writeAndFlush(pkg);
		}
	}

	@Override
	public String getSessionId() {
		//å§”æ‰˜
		return cache.getSessionId();
	}

	@Override
	public boolean isValid() {
		return valid;
	}

	public void setValid(boolean valid) {
		this.valid = valid;
	}

	@Override
	public String getUserId() {
		//å§”æ‰˜
		return cache.getUserId();
	}
}
```

**è·¯ç”±å¦‚ä½•ä½“ç°ï¼Ÿ**

```java
PeerSender sender = WorkerRouter.getInst().route(nodeId);
```


## é‚£PeerSenderæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ

è¿™é‡Œï¼Œå…¶å®PeerSenderå…¶å®æ˜¯ï¼Œä¸€ä¸ªå®¢æˆ·ç«¯çš„ç¨‹åºï¼Œé“¾æ¥çš„è¿œç¨‹NettyèŠ‚ç‚¹å°±æ˜¯RemoteSessionä¸­å­˜å‚¨çš„è¿œç¨‹èŠ‚ç‚¹ä¿¡æ¯ã€‚

```java
@Slf4j
@Data
public class PeerSender {

	private int reConnectCount = 0;

	private Channel channel;

	private ImNode imNode;
	/**
	 * å”¯ä¸€æ ‡è®°
	 */
	private boolean connectFlag = false;

	private UserDTO user;

	GenericFutureListener<ChannelFuture> closeListener = (ChannelFuture f) -> {
		log.info("åˆ†å¸ƒå¼è¿æ¥å·²ç»æ–­å¼€â€¦â€¦{}", imNode.toString());
		channel = null;
		connectFlag = false;
	};

	private GenericFutureListener<ChannelFuture> connectedListener = (ChannelFuture f) -> {
		final EventLoop eventLoop = f.channel().eventLoop();
		if (!f.isSuccess() && ++reConnectCount < 3) {
			log.info("è¿æ¥å¤±è´¥! åœ¨10sä¹‹åå‡†å¤‡å°è¯•ç¬¬{}æ¬¡é‡è¿!", reConnectCount);
			eventLoop.schedule(PeerSender.this::doConnect, 10, TimeUnit.SECONDS);
			connectFlag = false;
		} else {
			connectFlag = true;
			log.info(new Date() + "åˆ†å¸ƒå¼èŠ‚ç‚¹è¿æ¥æˆåŠŸ:{}", imNode.toString());
			channel = f.channel();
			channel.closeFuture().addListener(closeListener);

			// å‘é€é“¾æ¥æˆåŠŸçš„é€šçŸ¥
			Notification<ImNode> notification = new Notification<>(ImWorker.getInst().getLocalNodeInfo());
			notification.setType(Notification.CONNECT_FINISHED);
			String json = JsonUtil.pojoToJson(notification);
			ProtoMsg.Message pkg = NotificationMsgBuilder.buildNotification(json);
			writeAndFlush(pkg);
		}
	};


	private Bootstrap bootstrap;
	private EventLoopGroup g;

	public PeerSender(ImNode n) {
		this.imNode = n;

		// å®¢æˆ·ç«¯çš„æ˜¯Bootstrapï¼ŒæœåŠ¡ç«¯çš„åˆ™æ˜¯ ServerBootstrapã€‚éƒ½æ˜¯AbstractBootstrapçš„å­ç±»ã€‚
		bootstrap = new Bootstrap();

		// é€šè¿‡nioæ–¹å¼æ¥æ¥æ”¶è¿æ¥å’Œå¤„ç†è¿æ¥
		g = new NioEventLoopGroup();
	}

	/**
	 * é‡è¿
	 */
	public void doConnect() {

		// æœåŠ¡å™¨ipåœ°å€
		String host = imNode.getHost();
		// æœåŠ¡å™¨ç«¯å£
		int port = imNode.getPort();

		try {
			if (bootstrap != null && bootstrap.group() == null) {
				bootstrap.group(g);
				bootstrap.channel(NioSocketChannel.class);
				bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
				bootstrap.option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT);
				bootstrap.remoteAddress(host, port);

				// è®¾ç½®é€šé“åˆå§‹åŒ–
				bootstrap.handler(
						new ChannelInitializer<SocketChannel>() {
							@Override
							public void initChannel(SocketChannel ch) {
								ch.pipeline().addLast("decoder", new ProtobufDecoder());
								ch.pipeline().addLast("encoder", new ProtobufEncoder());
								ch.pipeline().addLast("imNodeHeartBeatClientHandler", new ImNodeHeartBeatClientHandler());
								ch.pipeline().addLast("exceptionHandler", new ImNodeExceptionHandler());
							}
						}
				);
				log.info(new Date() + "å¼€å§‹è¿æ¥åˆ†å¸ƒå¼èŠ‚ç‚¹:{}", imNode.toString());
				ChannelFuture f = bootstrap.connect();
				f.addListener(connectedListener);
				// é˜»å¡
//                 f.channel().closeFuture().sync();

			} else if (bootstrap.group() != null) {
				log.info(new Date() + "å†ä¸€æ¬¡å¼€å§‹è¿æ¥åˆ†å¸ƒå¼èŠ‚ç‚¹ : {}", imNode.toString());
				ChannelFuture f = bootstrap.connect();
				f.addListener(connectedListener);
			}
		} catch (Exception e) {
			log.info("å®¢æˆ·ç«¯è¿æ¥å¤±è´¥!" + e.getMessage());
		}

	}

	public void stopConnecting() {
		g.shutdownGracefully();
		connectFlag = false;
	}

	public void writeAndFlush(Object pkg) {
		if (!connectFlag) {
			log.error("åˆ†å¸ƒå¼èŠ‚ç‚¹æœªè¿æ¥: {}", imNode.toString());
			return;
		}
		channel.writeAndFlush(pkg);
	}


}
```


## WorkerRouterçš„æ ¸å¿ƒåŠŸèƒ½


WorkerRouterè·¯ç”±å™¨æœ‰ä¸€ä¸ª workerMap,ç”¨äºå°è£…å’Œä¿å­˜æ‰€æœ‰åœ¨çº¿çš„èŠ‚ç‚¹æ•°æ®ã€‚

> è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒååŠ å…¥é›†ç¾¤çš„èŠ‚ç‚¹ï¼Œä¹Ÿéœ€è¦ä¿å­˜ä¹‹å‰å·²ç»åŠ å…¥é›†ç¾¤çš„èŠ‚ç‚¹æ•°æ®ï¼Œ å…¶å®å°±æ˜¯ZkæŒ‡å®šè·¯å¾„ä¸‹çš„æ‰€æœ‰å­—èŠ‚ç‚¹ï¼ˆä¸ç®—è‡ªå·±ï¼‰

å½“æœ‰æ¶ˆæ¯è¿›è¡Œè½¬å‘çš„æ—¶å€™ï¼Œæ ¹æ®è¿œç¨‹NettyèŠ‚ç‚¹çš„idï¼Œåœ¨workerMap ä¸­æ‰¾å‡ºPeerSenderï¼Œè¿›è¡Œæ¶ˆæ¯çš„è½¬å‘ã€‚


> åªæœ‰æ¶‰åŠåˆ° **è¿œç¨‹ä¼šè¯** çš„åœºæ™¯æ‰ä¼šä½¿ç”¨åˆ°WorkerRouterã€‚ æœ¬åœ°ä¼šè¯æ˜¯ä¸éœ€è¦è·¯ç”±é€»è¾‘çš„ï¼Œç›´æ¥ç”±å½“å‰NettyèŠ‚ç‚¹è¿›è¡Œæ¶ˆæ¯çš„å‘é€ã€‚




















